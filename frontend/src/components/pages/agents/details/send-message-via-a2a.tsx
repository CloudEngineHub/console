/**
 * Copyright 2025 Redpanda Data, Inc.
 *
 * Use of this software is governed by the Business Source License
 * included in the file https://github.com/redpanda-data/redpanda/blob/dev/licenses/bsl.md
 *
 * As of the Change Date specified in that file, in accordance with
 * the Business Source License, use of this software will be governed
 * by the Apache License, Version 2.0
 */
/** biome-ignore-all lint/suspicious/useAwait: required for compatibility with A2A SDK streaming API */

import type { Artifact as A2AArtifact, Message, MessageSendParams, Task, TaskState } from '@a2a-js/sdk';
import { A2AClient } from '@a2a-js/sdk/client';
import { config } from 'config';
import type { Artifact, ArtifactPart, ChatMessage } from 'database/chat-db';
import { getAgentCardUrl } from 'utils/ai-agent.utils';
import { v4 as uuidv4 } from 'uuid';

type A2AApiResponse = {
  message: string;
  success: boolean;
  error?: string;
  taskId?: string;
  contextId?: string;
  taskState?: TaskState; // Current state of the task (e.g., 'input-required', 'completed', etc.)
  statusMessage?: string; // General status message for the current task state
  inputPrompt?: string; // Question/prompt from agent when taskState is 'input-required'
  authPrompt?: string; // Authentication requirement message when taskState is 'auth-required'
  failureReason?: string; // Failure/rejection reason when taskState is 'failed' or 'rejected'
  reasoning?: string;
  completionMessage?: string; // Separate completion message for tasks
  artifacts?: Artifact[]; // Artifacts generated by the agent
};

// Limit chat history to last 15 messages (30 total including responses)
export const A2A_CHAT_HISTORY_MESSAGE_LIMIT = 15;

type SendMessageViaA2AProps = {
  message: string;
  chatHistory: ChatMessage[]; // Reserved for future use with conversation context
  agentUrl: string;
  contextId?: string; // Context ID for grouping related interactions
  taskId?: string; // Task ID if continuing an existing task
  onStreamUpdate?: (partialContent: string) => void | Promise<void>;
};

/**
 * Extracts text from a task status message
 */
function extractTaskStatusText(task: Task): string {
  // Check if task has artifacts first (final output)
  if (task.artifacts && task.artifacts.length > 0) {
    const artifact = task.artifacts[0];
    if (artifact.parts && artifact.parts.length > 0) {
      const part = artifact.parts[0];
      if (part.kind === 'text') {
        return part.text || '';
      }
    }
  }

  // Extract text from status message
  if (task.status.message) {
    const statusMessage = task.status.message as { parts?: { kind: string; text?: string }[] };
    if (statusMessage.parts && statusMessage.parts.length > 0) {
      const part = statusMessage.parts[0];
      if (part.kind === 'text' && part.text) {
        return part.text;
      }
    }
  }

  // Fallback to basic status
  return `Task ${task.status.state}`;
}

/**
 * Extracts text content from a Message or Task result
 */
function extractTextFromResult(result: Message | Task): string {
  if (result.kind === 'task') {
    const task = result as Task;
    return extractTaskStatusText(task);
  }

  // Handle direct message response
  const message = result as Message;
  if (message.parts && message.parts.length > 0) {
    const part = message.parts[0];
    if (part.kind === 'text') {
      return part.text || '';
    }
  }

  return 'No response content available';
}

type StreamEvent = {
  kind: string;
  id?: string;
  taskId?: string;
  contextId?: string;
  parts?: { kind: string; text?: string }[];
  status?: {
    state?: TaskState;
    message?: {
      parts?: { kind: string; text?: string }[];
      kind?: string;
      messageId?: string;
    };
  };
  artifact?: A2AArtifact;
  artifacts?: A2AArtifact[];
  final?: boolean;
};

/**
 * Checks if a message is a tool request, response, or error
 */
function isToolMessage(text: string): boolean {
  return (
    text.startsWith('Tool request:') || text.startsWith('Tool response:') || text.startsWith('Tool response error:')
  );
}

/**
 * Extracts input prompt from require_input tool response
 * Returns the message that should be shown to the user when agent needs input
 */
function extractInputPrompt(text: string): string | null {
  // Check if this is a tool response for require_input
  if (!text.startsWith('Tool response:')) {
    return null;
  }

  try {
    // Extract JSON from "Tool response: {...}"
    const jsonStart = text.indexOf('{');
    if (jsonStart === -1) {
      return null;
    }

    const jsonStr = text.substring(jsonStart);
    const response = JSON.parse(jsonStr) as {
      status?: string;
      input_message?: string;
      message?: string;
    };

    // Check if this is a require_input response
    if (response.status === 'require_input' && response.input_message) {
      return response.input_message;
    }
  } catch {
    // JSON parse failed, not a valid tool response
    return null;
  }

  return null;
}

/**
 * Extracts authentication prompt from require_auth tool response
 * Returns the message that should be shown when agent needs authentication
 */
function extractAuthPrompt(text: string): string | null {
  // Check if this is a tool response for require_auth or similar
  if (!text.startsWith('Tool response:')) {
    return null;
  }

  try {
    const jsonStart = text.indexOf('{');
    if (jsonStart === -1) {
      return null;
    }

    const jsonStr = text.substring(jsonStart);
    const response = JSON.parse(jsonStr) as {
      status?: string;
      auth_message?: string;
      message?: string;
    };

    // Check if this is a require_auth response
    if (response.status === 'require_auth' && response.auth_message) {
      return response.auth_message;
    }
  } catch {
    // JSON parse failed
    return null;
  }

  return null;
}

/**
 * Extracts failure reason from error messages or tool responses
 * Returns the reason why a task failed or was rejected
 */
function extractFailureReason(text: string): string | null {
  // Check for tool response errors
  if (text.startsWith('Tool response error:')) {
    return text.replace('Tool response error:', '').trim();
  }

  // Check for structured error in tool response
  if (text.startsWith('Tool response:')) {
    try {
      const jsonStart = text.indexOf('{');
      if (jsonStart !== -1) {
        const jsonStr = text.substring(jsonStart);
        const response = JSON.parse(jsonStr) as {
          error?: string;
          message?: string;
          reason?: string;
        };

        return response.error || response.reason || response.message || null;
      }
    } catch {
      // JSON parse failed
    }
  }

  // For plain error messages
  if (text.toLowerCase().includes('error') || text.toLowerCase().includes('failed')) {
    return text;
  }

  return null;
}

/**
 * Extracts a general status message from task status
 * Returns a human-readable status message for any task state
 */
function extractStatusMessage(taskState: TaskState, messageText?: string): string {
  // Use custom message if available and not a tool message
  if (messageText && !isToolMessage(messageText)) {
    return messageText;
  }

  // Default messages for each state
  switch (taskState) {
    case 'submitted':
      return 'Task has been submitted and is queued for processing';
    case 'working':
      return 'Task is in progress';
    case 'input-required':
      return 'Agent is waiting for your input';
    case 'auth-required':
      return 'Authentication is required to continue';
    case 'completed':
      return 'Task completed successfully';
    case 'failed':
      return 'Task failed';
    case 'rejected':
      return 'Task was rejected';
    case 'canceled':
      return 'Task was canceled';
    default:
      return 'Task status is unknown';
  }
}

/**
 * Extracts text from a status update event
 */
function extractStatusText(evt: StreamEvent): string | null {
  const statusMessage = evt.status?.message?.parts?.[0];
  if (statusMessage?.kind === 'text' && statusMessage.text) {
    return statusMessage.text;
  }
  return null;
}

/**
 * Extracts text from a message event
 */
function extractMessageText(evt: StreamEvent): string | null {
  if (evt.parts?.[0]?.kind === 'text') {
    return evt.parts[0].text || '';
  }
  return null;
}

/**
 * Extracts text from a task event
 */
function extractTaskText(evt: StreamEvent): string | null {
  // Check if task has artifacts (final output)
  if (evt.artifacts && evt.artifacts.length > 0) {
    const artifact = evt.artifacts[0];
    if (artifact.parts && artifact.parts.length > 0) {
      const part = artifact.parts[0];
      if (part.kind === 'text' && part.text) {
        return part.text;
      }
    }
  }

  // Extract text from status message
  if (evt.status?.message?.parts?.[0]?.kind === 'text') {
    return evt.status.message.parts[0].text || null;
  }

  return null;
}

type StreamingResult = {
  message: string;
  taskId?: string;
  contextId?: string;
  taskState?: TaskState;
  statusMessage?: string;
  inputPrompt?: string;
  authPrompt?: string;
  failureReason?: string;
  reasoning?: string;
  completionMessage?: string;
  artifacts?: Artifact[];
};

/**
 * Processes streaming events from the A2A agent with progressive updates
 */
// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: This function handles multiple distinct event types from the A2A protocol (task, status-update, message, artifact-update) and is already well-structured with helper functions
async function processStreamingResponse(
  stream: AsyncIterable<unknown>,
  onStreamUpdate?: (partialContent: string, reasoning?: string) => void | Promise<void>
): Promise<StreamingResult> {
  let taskPlan = '';
  let taskId = '';
  let contextId = '';
  let taskState: TaskState | undefined;
  let statusMessage: string | undefined;
  let inputPrompt: string | undefined;
  let authPrompt: string | undefined;
  let failureReason: string | undefined;
  const reasoningSteps: string[] = [];
  const artifacts: Artifact[] = [];
  let lastAgentMessage = '';
  let hasSeenFinalStatus = false;

  for await (const event of stream) {
    const evt = event as StreamEvent;

    // Extract contextId from any event that has it
    if (evt.contextId) {
      contextId = evt.contextId;
    }

    // Handle task creation
    if (evt.kind === 'task') {
      taskId = evt.id || '';

      // Extract artifacts from task if present
      if (evt.artifacts && evt.artifacts.length > 0) {
        for (const artifact of evt.artifacts) {
          // Extract text from parts if present
          const textFromParts = artifact.parts
            .filter((p): p is { kind: 'text'; text: string } => p.kind === 'text' && 'text' in p && !!p.text)
            .map((p) => p.text)
            .join('\n\n');

          artifacts.push({
            id: artifact.artifactId,
            name: artifact.name,
            description: artifact.description,
            text: textFromParts,
            parts: artifact.parts as unknown as ArtifactPart[],
          });
        }
      }

      // Extract and display task description/plan
      const taskText = extractTaskText(evt);
      if (taskText) {
        taskPlan = taskText;
        if (onStreamUpdate) {
          await onStreamUpdate(taskPlan);
        }
      }
      continue;
    }

    // Handle status updates
    if (evt.kind === 'status-update') {
      // Extract taskId from status updates as well
      if (evt.taskId) {
        taskId = evt.taskId;
      }

      // Extract and track task state
      if (evt.status?.state) {
        taskState = evt.status.state;
      }

      const statusText = extractStatusText(evt);

      if (statusText) {
        // Handle state-specific extractions
        if (taskState === 'input-required') {
          const prompt = extractInputPrompt(statusText);
          if (prompt) {
            inputPrompt = prompt;
            // Don't add require_input tool responses to reasoning - show prominently
            if (onStreamUpdate && taskPlan) {
              await onStreamUpdate(taskPlan, reasoningSteps.join('\n\n'));
            }
            // Skip adding this to reasoning and continue
            if (evt.final) {
              hasSeenFinalStatus = true;
              break;
            }
            continue;
          }
        } else if (taskState === 'auth-required') {
          const prompt = extractAuthPrompt(statusText);
          if (prompt) {
            authPrompt = prompt;
            // Don't add auth prompts to reasoning - show prominently
            if (onStreamUpdate && taskPlan) {
              await onStreamUpdate(taskPlan, reasoningSteps.join('\n\n'));
            }
            if (evt.final) {
              hasSeenFinalStatus = true;
              break;
            }
            continue;
          }
        } else if (taskState === 'failed' || taskState === 'rejected') {
          const reason = extractFailureReason(statusText);
          if (reason) {
            failureReason = reason;
            // Failures should be visible in reasoning too for debugging
            reasoningSteps.push(statusText);
            if (onStreamUpdate && taskPlan) {
              await onStreamUpdate(taskPlan, reasoningSteps.join('\n\n'));
            }
            if (evt.final) {
              hasSeenFinalStatus = true;
              break;
            }
            continue;
          }
        }

        // Check if this is a tool message (reasoning) or agent message
        if (isToolMessage(statusText)) {
          // Accumulate reasoning
          reasoningSteps.push(statusText);
          if (onStreamUpdate && taskPlan) {
            // Update with task plan + reasoning
            await onStreamUpdate(taskPlan, reasoningSteps.join('\n\n'));
          }
        } else {
          // This might be the final agent message
          lastAgentMessage = statusText;
          if (onStreamUpdate && taskPlan) {
            // Update with task plan + reasoning
            await onStreamUpdate(taskPlan, reasoningSteps.join('\n\n'));
          }
        }
      }

      // Update status message for current state
      if (taskState) {
        statusMessage = extractStatusMessage(taskState, statusText || undefined);
      }

      if (evt.final) {
        hasSeenFinalStatus = true;
        break;
      }
      continue;
    }

    // Handle message events (for simple streaming responses without tasks)
    if (evt.kind === 'message') {
      // Extract taskId from message events as well
      if (evt.taskId) {
        taskId = evt.taskId;
      }

      const messageText = extractMessageText(evt);
      if (messageText) {
        // Handle state-specific extractions
        if (taskState === 'input-required') {
          const prompt = extractInputPrompt(messageText);
          if (prompt) {
            inputPrompt = prompt;
            // Don't add require_input to reasoning - user should see this prominently
            continue;
          }
        } else if (taskState === 'auth-required') {
          const prompt = extractAuthPrompt(messageText);
          if (prompt) {
            authPrompt = prompt;
            // Don't add auth prompts to reasoning - show prominently
            continue;
          }
        } else if (taskState === 'failed' || taskState === 'rejected') {
          const reason = extractFailureReason(messageText);
          if (reason) {
            failureReason = reason;
            // Add to reasoning for debugging visibility
            reasoningSteps.push(messageText);
            if (onStreamUpdate && taskPlan) {
              await onStreamUpdate(taskPlan, reasoningSteps.join('\n\n'));
            }
            continue;
          }
        }

        // Check if this is a tool message (including errors)
        if (isToolMessage(messageText)) {
          // Add tool messages (including errors) to reasoning steps
          reasoningSteps.push(messageText);
          if (onStreamUpdate && taskPlan) {
            // Update with task plan + reasoning (including tool errors)
            await onStreamUpdate(taskPlan, reasoningSteps.join('\n\n'));
          }
        } else if (!taskId) {
          // For non-task, non-tool messages, concatenate to task plan
          taskPlan += messageText;
          if (onStreamUpdate) {
            await onStreamUpdate(taskPlan);
          }
        }
      }
      continue;
    }

    // Handle artifact updates
    if (evt.kind === 'artifact-update') {
      // Extract taskId from artifact updates as well
      if (evt.taskId) {
        taskId = evt.taskId;
      }

      // Store artifact separately, do not display as part of message content
      if (evt.artifact) {
        // Extract text from parts if present
        const textFromParts = evt.artifact.parts
          .filter((p): p is { kind: 'text'; text: string } => p.kind === 'text' && 'text' in p && !!p.text)
          .map((p) => p.text)
          .join('\n\n');

        artifacts.push({
          id: evt.artifact.artifactId,
          name: evt.artifact.name,
          description: evt.artifact.description,
          text: textFromParts,
          parts: evt.artifact.parts as unknown as ArtifactPart[],
        });
      }
    }
  }

  // Return the result with metadata
  const result: StreamingResult = {
    message: taskPlan || lastAgentMessage || 'Agent completed task successfully',
  };

  if (taskId) {
    result.taskId = taskId;
  }

  if (contextId) {
    result.contextId = contextId;
  }

  if (taskState) {
    result.taskState = taskState;
  }

  if (statusMessage) {
    result.statusMessage = statusMessage;
  }

  if (inputPrompt) {
    result.inputPrompt = inputPrompt;
  }

  if (authPrompt) {
    result.authPrompt = authPrompt;
  }

  if (failureReason) {
    result.failureReason = failureReason;
  }

  if (reasoningSteps.length > 0) {
    result.reasoning = reasoningSteps.join('\n\n');
  }

  if (artifacts.length > 0) {
    result.artifacts = artifacts;
  }

  // If we have a final agent message that's different from the task plan and we saw final status,
  // include it as a separate completion message
  if (hasSeenFinalStatus && lastAgentMessage && lastAgentMessage !== taskPlan && !isToolMessage(lastAgentMessage)) {
    result.completionMessage = lastAgentMessage;
  }

  return result;
}

/**
 * Sends a non-streaming message and returns the response
 */
// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: This function handles multiple distinct task states from the A2A protocol (submitted, working, input-required, auth-required, completed, failed, rejected, canceled, unknown) and is already well-structured with helper functions
async function sendNonStreamingMessage(client: A2AClient, sendParams: MessageSendParams): Promise<A2AApiResponse> {
  const response = await client.sendMessage(sendParams);

  if ('error' in response) {
    const errorMessage = response.error?.message || 'Unknown error from agent';
    return {
      success: false,
      message: errorMessage,
      error: errorMessage,
    };
  }

  const responseText = extractTextFromResult(response.result);
  const result = response.result as Task | Message;

  // Extract taskId and contextId from the result
  const taskId = result.kind === 'task' ? (result as Task).id : (result as Message).taskId;
  const contextId = result.kind === 'task' ? (result as Task).contextId : (result as Message).contextId;

  // Extract task state from task result
  let taskState: TaskState | undefined;
  let statusMessage: string | undefined;
  let inputPrompt: string | undefined;
  let authPrompt: string | undefined;
  let failureReason: string | undefined;

  if (result.kind === 'task') {
    const taskResult = result as Task;
    taskState = taskResult.status.state;

    // Extract state-specific information from status message
    if (taskResult.status.message?.parts) {
      for (const part of taskResult.status.message.parts) {
        if (part.kind === 'text' && part.text) {
          const text = part.text;

          // Extract prompts/reasons based on state
          if (taskState === 'input-required') {
            const prompt = extractInputPrompt(text);
            if (prompt) {
              inputPrompt = prompt;
              break;
            }
          } else if (taskState === 'auth-required') {
            const prompt = extractAuthPrompt(text);
            if (prompt) {
              authPrompt = prompt;
              break;
            }
          } else if (taskState === 'failed' || taskState === 'rejected') {
            const reason = extractFailureReason(text);
            if (reason) {
              failureReason = reason;
              break;
            }
          }
        }
      }
    }

    // Generate status message for current state
    if (taskState) {
      const messageText = taskResult.status.message?.parts?.find((p) => p.kind === 'text' && 'text' in p)?.text;
      statusMessage = extractStatusMessage(taskState, messageText);
    }
  }

  // Extract artifacts from task if present
  let artifacts: Artifact[] | undefined;
  if (result.kind === 'task') {
    const taskResult = result as Task;
    if (taskResult.artifacts && taskResult.artifacts.length > 0) {
      artifacts = taskResult.artifacts.map((artifact) => {
        // Extract text from parts if present
        const textFromParts = artifact.parts
          .filter((p): p is { kind: 'text'; text: string } => p.kind === 'text' && 'text' in p && !!p.text)
          .map((p) => p.text)
          .join('\n\n');

        return {
          id: artifact.artifactId,
          name: artifact.name,
          description: artifact.description,
          text: textFromParts,
          parts: artifact.parts as unknown as ArtifactPart[],
        };
      });
    }
  }

  return {
    message: responseText,
    success: true,
    taskId,
    contextId,
    taskState,
    statusMessage,
    inputPrompt,
    authPrompt,
    failureReason,
    artifacts,
  };
}

const fetchWithCustomHeader: typeof fetch = async (url, init) => {
  const headers = new Headers(init?.headers);
  headers.set('Authorization', `Bearer ${config.jwt}`);

  const newInit = { ...init, headers };

  return fetch(url, newInit);
};

/**
 * Sends a message to an AI agent via the A2A (Agent-to-Agent) protocol.
 * Uses the official @a2a-js/sdk for proper A2A protocol communication.
 * Supports streaming responses from agents.
 *
 * @see https://github.com/a2aproject/a2a-js for SDK documentation
 */
export const sendMessageViaA2A = async ({
  message,
  agentUrl,
  contextId,
  taskId,
  onStreamUpdate,
}: SendMessageViaA2AProps): Promise<A2AApiResponse> => {
  try {
    // Resolve the full agent card URL from the provided agent URL
    const agentCardUrl = getAgentCardUrl({ agentUrl });

    // Create A2A client from the agent card URL
    const client = await A2AClient.fromCardUrl(agentCardUrl, { fetchImpl: fetchWithCustomHeader });

    const sendParams: MessageSendParams = {
      message: {
        messageId: uuidv4(),
        contextId,
        taskId,
        role: 'user',
        parts: [{ kind: 'text', text: message }],
        kind: 'message',
      },
    };

    // Try streaming first for better UX
    try {
      const stream = client.sendMessageStream(sendParams);
      const result = await processStreamingResponse(stream, onStreamUpdate);
      return {
        message: result.message,
        success: true,
        taskId: result.taskId,
        contextId: result.contextId,
        taskState: result.taskState,
        statusMessage: result.statusMessage,
        inputPrompt: result.inputPrompt,
        authPrompt: result.authPrompt,
        failureReason: result.failureReason,
        reasoning: result.reasoning,
        completionMessage: result.completionMessage,
        artifacts: result.artifacts,
      };
    } catch {
      // Fall back to non-streaming if streaming is not supported
      return await sendNonStreamingMessage(client, sendParams);
    }
  } catch (error) {
    let errorMessage = 'Failed to send message to agent. Please try again later.';

    if (error instanceof Error) {
      if (error.message.includes('fetch') || error.message.includes('network')) {
        errorMessage = 'Cannot connect to agent. Please check that the agent is running and accessible.';
      } else if (error.message.includes('agent-card') || error.message.includes('card')) {
        errorMessage = 'Unable to load agent card. The agent may not be configured correctly.';
      } else {
        errorMessage = error.message;
      }
    }

    return {
      success: false,
      message: errorMessage,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
};
